This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-09T16:35:49.023Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
brute_partition.cpp
dp_partition.cpp
Makefile
run_tests.sh
test_cases.txt
test_generator.cpp
time_outs.txt

================================================================
Files
================================================================

================
File: brute_partition.cpp
================
#include <iostream>
#include <vector>
#include <fstream>
#include <sstream>
#include <numeric>

using namespace std;

class SolutionBrute {
public:
    bool canPartition(vector<int> &nums) {
        int totalSum = accumulate(nums.begin(), nums.end(), 0);
        if (totalSum % 2 != 0) return false;

        int subSetSum = totalSum / 2;
        int n = nums.size();
        return dfs(nums, n - 1, subSetSum);
    }

    bool dfs(vector<int> &nums, int n, int subSetSum) {
        if (subSetSum == 0) return true;
        if (n < 0 || subSetSum < 0) return false;

        return dfs(nums, n - 1, subSetSum - nums[n]) || dfs(nums, n - 1, subSetSum);
    }
};

vector<int> readTestCase(const string& filename, int testID) {
    ifstream file(filename);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        exit(1);
    }
    
    string line;
    while (getline(file, line)) {
        stringstream ss(line);
        int id, size;
        ss >> id >> size;
        
        if (id == testID) {
            vector<int> arr(size);
            for (int i = 0; i < size; i++) {
                ss >> arr[i];
            }
            return arr;
        }
    }
    
    cerr << "Test ID not found: " << testID << endl;
    exit(1);
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        cerr << "Usage: ./brute_partition <testID>" << endl;
        return 1;
    }

    int testID = stoi(argv[1]);
    vector<int> nums;
    nums = readTestCase("test_cases.txt", testID);
    SolutionBrute bruteSolution;
    string ret = (bruteSolution.canPartition(nums)) ? "Can Partition" : "CANNOT Partition";
    cout << ret << endl;

    return 0;
}

================
File: dp_partition.cpp
================
#include <iostream>
#include <vector>
#include <fstream>
#include <sstream>
#include <numeric>

using namespace std;

class SolutionDP {
public:
    bool isSubsetSum(int n, vector<int>& arr, int sum, vector<vector<int>> &memo) {
        if (sum == 0) return true;
        if (n == 0) return false;
        
        if (memo[n-1][sum] != -1) 
            return memo[n-1][sum];

        if (arr[n-1] > sum)
            return isSubsetSum(n-1, arr, sum, memo);

        return memo[n-1][sum] = 
               isSubsetSum(n-1, arr, sum, memo) || 
               isSubsetSum(n-1, arr, sum - arr[n-1], memo);
    }

    bool canPartition(vector<int>& arr) {
        int sum = accumulate(arr.begin(), arr.end(), 0);
        if (sum % 2 != 0) return false;
        
        vector<vector<int>> memo(arr.size(), vector<int>(sum+1, -1));
        return isSubsetSum(arr.size(), arr, sum / 2, memo);
    }
};

vector<int> readTestCase(const string& filename, int testID) {
    ifstream file(filename);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        exit(1);
    }
    
    string line;
    while (getline(file, line)) {
        stringstream ss(line);
        int id, size;
        ss >> id >> size;
        
        if (id == testID) {
            vector<int> arr(size);
            for (int i = 0; i < size; i++) {
                ss >> arr[i];
            }
            return arr;
        }
    }
    
    cerr << "Test ID not found: " << testID << endl;
    exit(1);
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        cerr << "Usage: ./dp_partition <testID>" << endl;
        return 1;
    }

    int testID = stoi(argv[1]);
    vector<int> nums;
    nums = readTestCase("test_cases.txt", testID);
    SolutionDP dpSolution;
    string ret = (dpSolution.canPartition(nums)) ? "Can Partition" : "CANNOT Partition";
    cout << ret << endl;
    return 0;
}

================
File: Makefile
================
# Compiler
CXX = g++
CXXFLAGS = -std=c++11 -Wall

# Executables
DP_EXEC = dp_partition
BRUTE_EXEC = brute_partition
TEST_EXEC = test_generator  # Fix name to match consistency

# Source files
DP_SRC = dp_partition.cpp
BRUTE_SRC = brute_partition.cpp
TEST_SRC = test_generator.cpp  # Fix source file variable

# Build all targets
all: $(DP_EXEC) $(BRUTE_EXEC) $(TEST_EXEC)

$(DP_EXEC): $(DP_SRC)
	$(CXX) $(CXXFLAGS) -o $@ $^

$(BRUTE_EXEC): $(BRUTE_SRC)
	$(CXX) $(CXXFLAGS) -o $@ $^

$(TEST_EXEC): $(TEST_SRC)  # Fix the dependency
	$(CXX) $(CXXFLAGS) -o $@ $^

# Clean build files
clean:
	rm -f $(DP_EXEC) $(BRUTE_EXEC) $(TEST_EXEC)

================
File: run_tests.sh
================
#!/bin/bash

# check if test case number exists
if [ $# -ne 1 ]; then
    echo "Usage: ./run_tests.sh <test_case_number>"
    exit 1
fi

TEST_ID=$1
OUTPUT_FILE="time_outs.txt"

# time the exec and log it into the out file
run_test() {
    EXEC=$1
    TEST_ID=$2
    START_TIME=$(date +%s.%N)
    ./$EXEC $TEST_ID > /dev/null 2>&1
    END_TIME=$(date +%s.%N)
    TIME_TAKEN=$(echo "$END_TIME - $START_TIME" | bc)  # elapsed time
    echo "$EXEC (Test ID: $TEST_ID) - $TIME_TAKEN seconds" | tee -a $OUTPUT_FILE
}

# clear previous outputs
echo "Running test case: $TEST_ID" | tee -a $OUTPUT_FILE

# run both algos
run_test "dp_partition" $TEST_ID
run_test "brute_partition" $TEST_ID

echo "Results saved to $OUTPUT_FILE"

================
File: test_cases.txt
================
# Format: ID [array_size] array_elements
1 5 14 16 18 20 22 
2 10 14 16 18 20 22 24 26 28 30 32 
3 15 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 
4 20 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 
5 25 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 
6 28 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 
7 29 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 
8 10 70312 90312 110312 130312 150312 170312 190312 210312 230312 250312 
9 10 156250 176250 196250 216250 236250 256250 276250 296250 316250 336250 
10 10 343750 363750 383750 403750 423750 443750 463750 483750 503750 523750 
11 10 750000 770000 790000 810000 830000 850000 870000 890000 910000 930000 
12 10 1625000 1645000 1665000 1685000 1705000 1725000 1745000 1765000 1785000 1805000 
13 10 3500000 3520000 3540000 3560000 3580000 3600000 3620000 3640000 3660000 3680000 
14 10 7500000 7520000 7540000 7560000 7580000 7600000 7620000 7640000 7660000 7680000 
15 10 16000000 16020000 16040000 16060000 16080000 16100000 16120000 16140000 16160000 16180000
16 30 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68

================
File: test_generator.cpp
================
#include <bits/stdc++.h>

using namespace std;

#define FILENAME "test_cases.txt"

int main(int argc, char* argv[]) {
    /* Choose a test case ID and append it to the test_cases.txt file */
    if (argc != 4) {
        cerr << "Usage: ./test_generator <test_id> <array_size> <big_numbers_flag>" << endl;
        return 1;
    }

    int testID = stoi(argv[1]);
    int array_size = stoi(argv[2]);
    int big_numbers = stoi(argv[3]);

    ofstream file(FILENAME, ios::app);

    if (!file) {
        cerr << "Error opening file: " << FILENAME << endl;
        return -1;
    }

    /* Append the test ID and array size */
    file << testID << " " << array_size << " ";

    if (big_numbers) {
        /* We'll want to see the running time of the DP approach 
        * against a huge total sum */
        for (int i = 0; i < array_size; i++) {
            int divider_metric = (int) pow(2, (15 - testID));
            int val = (testID + 1) * 1000000 / divider_metric + (i * 20000); // Large values to increase sum
            file << val << " ";
        }
    } else {
        /* Append the array elements */
        /* Only this function should be changed when adding a new special
        * test case */
        for (int i = 0; i < array_size; i++) {
            int val = 10 + (i * 2);
            file << i << " ";
        }
    }

    file << endl;
    file.close(); 

    return 0;
}

================
File: time_outs.txt
================
Running test case: 1
dp_partition (Test ID: 1) - .050159400 seconds
brute_partition (Test ID: 1) - .034101500 seconds
Running test case: 2
dp_partition (Test ID: 2) - .015145100 seconds
brute_partition (Test ID: 2) - .014197100 seconds
Running test case: 3
dp_partition (Test ID: 3) - .009362400 seconds
brute_partition (Test ID: 3) - .007672501 seconds
Running test case: 4
dp_partition (Test ID: 4) - .008172700 seconds
brute_partition (Test ID: 4) - .007888000 seconds
Running test case: 5
dp_partition (Test ID: 5) - .009914000 seconds
brute_partition (Test ID: 5) - .146771999 seconds
Running test case: 6
dp_partition (Test ID: 6) - .011176100 seconds
brute_partition (Test ID: 6) - .006693700 seconds
Running test case: 7
dp_partition (Test ID: 7) - .011114900 seconds
brute_partition (Test ID: 7) - 2.063914588 seconds
Running test case: 8
dp_partition (Test ID: 8) - .035246400 seconds
brute_partition (Test ID: 8) - .011480999 seconds
Running test case: 9
dp_partition (Test ID: 9) - .044749200 seconds
brute_partition (Test ID: 9) - .009651600 seconds
Running test case: 10
dp_partition (Test ID: 10) - .059640000 seconds
brute_partition (Test ID: 10) - .011119000 seconds
Running test case: 11
dp_partition (Test ID: 11) - .156676099 seconds
brute_partition (Test ID: 11) - .009037500 seconds
Running test case: 12
dp_partition (Test ID: 12) - .226312499 seconds
brute_partition (Test ID: 12) - .011636800 seconds
Running test case: 13
dp_partition (Test ID: 13) - .466639397 seconds
brute_partition (Test ID: 13) - .011151200 seconds
Running test case: 14
dp_partition (Test ID: 14) - .928440896 seconds
brute_partition (Test ID: 14) - .010843400 seconds
Running test case: 15
dp_partition (Test ID: 15) - 5.844956375 seconds
brute_partition (Test ID: 15) - .009967400 seconds
